# 动态存储管理

## 概述

+ **动态存储管理**的**基本问题**：
  + 系统如何**应用户提出的“请求”分配内存**？
  + 又如何**回收**那些用户**不再使用而“释放”的内存**，以备新的“请求"产生时重新进行分配？
+ 对任意的动态存储管理系统：
  + 在**刚开工**时，**整个内存区**是一个 **“空闲块”**（在编译程序中称之为 **“堆”**）；随着用户进入系统，先后提出存储请求，系统则依次进行分配
  + 在**系统运行的初期**，整个内存区基本上分隔成两大部分：**低地址区**包含若干**占用块**；**高地址区**（即**分配后的剩余部分**）是一个 **“空闲块”**
  + 假如此时又有新的用户进入系统请求分配内存，则系统通常有两种做法：
    + 策略一：系统**继续从高地址的空闲块中进行分配**，而不理会已分配给用户的内存区是否已空闲，**直到分配无法进行**（即剩余的空闲块不能满足分配的请求）时，系统才去**回收所有用户不再使用的空闲块**，并且重新组织内存，**将所有空闲的内存区连接在一起成为一个大的空闲块**
    + 策略二：用户**一旦运行结束**，便**将它所占内存区释放成为空闲块**，同时，每当新的用户**请求分配内存**时，系统需要**巡视整个内存区中所有空闲块**，并从中**找出一个“合适”的空闲块分配之**
      + 由此，系统需建立一张**记录所有空闲块的“可利用空间表”**，此表的结构可以是 **“目录表”**，也可以是 **“链表”**

## 可利用空间表及分配方法

+ 对于目录表，其情况比较简单；在此仅就**链表**的情况进行讨论
+ **可利用空间表**亦称做 **“存储池”**；根据系统运行的不同情况，可利用空间表可以有下列3种不同的**结构形式**：
  + 系统运行期间所有用户请求分配的**存储量大小相同**
    + **通常做法**：
      + 在**系统开始运行**时将**归它使用的内存区**按**所需大小分割成若干大小相同的块**，然后用**指针链接**成一个可利用空间表
      + 由于表中结点大小相同，则**分配时无需查找**，只要**将第一个结点分配给用户**即可
      + 同样，当用户**释放内存**时，系统只要将**用户释放的空闲块插入在表头**即可
    + 这种情况下的可利用空间表实质上是一个**链栈**
  + 系统运行期间用户请求分配的**存储量有若干种大小的规格**
    + **通常做法**：
      + 一般情况下是建立**若干个可利用空间表**，**同一链表**中的**结点大小相同**
        + 每个结点中第一个字设有**链域**（link）、**标志域**（tag）和**结点类型域**（type）
          + **标志域**指示状态（例如 **“0”** 表示**空闲块**，**“1”** 表示**占用块**
          + **结点类型域**指示**结点的大小**
      + 分配和回收的方法在很大程度上和第一种情况类似，但存在以下特殊情况：
        + 当**结点大小和请求分配的量相同的链表为空**时，需查询**结点较大的链表**，并从中**取出一个结点**，将其中**一部分内存分配给用户**，而将**剩余部分插入到相应大小的链表**中
        + 回收时，也只要将**释放的空闲块**插入到**相应大小的链表的表头中**去即可
      + 这种情况的系统还有一个特殊的问题要处理：即当**结点与请求相符的链表和结点更大的链表均为空**时，分配不能进行，而实际上内存空间并不一定不存在所需大小的连续空间，只是由于在系统运行过程中，**频繁出现小块的分配和回收**，使得**大结点链表中的空闲块被分隔成小块**后**插入在小结点的链表**中
        + 此时若要使系统能继续运行，就必须**重新组织内存**，即**执行“存储紧缩”的操作**
  + 系统在运行期间分配给用户的**内存块的大小不固定**，可以**随请求而变**，从而**可利用空间表中的结点**即**空闲块的大小**也是**随意**的；通常，操作系统中的可利用空闾表属这种类型
    + **系统刚开始工作**时，**整个内存空间是一个空闲块**，即可利用空间表中只有一个**大小**为**整个内存区**的**结点**；随着分配和回收的进行，可利用空间表中的结点大小和个数也随之而变
    + 由于链表中结点大小不同，则**结点的结构**与前两种情况也有所不同，结点中除**标志域**和**链域**之外，尚需有一个**结点大小域**（size），以指示**空闲块的存储量**；同时设**space域**，为一个**地址连续的内存空间**
    + 假设某用户需**大小为$n$的内存**：
      + 可利用空间表中**仅有一块大小为$m \geqslant n$的空闲块**：
        + 只需将**其中大小为$n$的一部分**分配给申请分配的用户，同时将**剩余大小为$m - n$的部分作为一个结点留在链表中**即可
      + 可利用空间表中**有若干个不小于$n$的空闲块**，有三种分配策略：
        + **首次拟合法**：从**表头指针开始查找可利用空间表**，将**找到的第一个大小不小于$n$的空闲块的一部分**分配给用户
          + 可利用空间表本身既不按结点的初始地址有序，也不按结点的大小有序
          + 在**回收**时，只要将**释放的空闲块插入在链表的表头**即可
          + **费时最短**（**从不查找链表**）
        + **最佳拟合法**：将可利用空间表中一个**不小于$n$且最接近$n$的空闲块的一部分**分配给用户
          + 系统在分配前首先要对可利用空间表**从头到尾扫视一遍**，然后从中找出一块不小于$n$且最接近$n$的空闲块进行分配
          + 在用最佳拟合法进行分配时，为了避免每次分配都要扫视整个链表，通常**预先设定可利用空间表的结构**按**空间块的大小**满足**自小至大有序**
            + 由此，只需找到**第一块大于$n$的空闲块**即可进行**分配**；但在**回收**时，必须将**释放的空闲块插入到合适的位置**上去
          + 适用于**请求分配的内存大小范围较广**的系统
          + **费时最长**（**分配**和**回收**都**需要查找链表**）
        + **最差拟合法**：将可利用空间表中一个**不小于$n$且是链表中最大的空闲块的一部分**分配给用户
          + 与最佳拟合法类似，一般**预先设定可利用空间表的结构**按**空间块的大小**满足**自大至小有序**
          + 适用于**请求分配的内存大小范围较窄**的系统
          + **费时居中**（**分配**时**不需要查找链表（直接取第一个）**，**回收**时需要**查找链表**）

## 边界标识法

+ **边界标识法**（boundary tag method）是操作系统中用以进行动态分区分配的一种存储管理方法，它属于上一节讨论中的第三种情况（系统在运行期间分配给用户的内存块的大小不固定，可以随请求而变，从而可利用空间表中的结点即空闲块的大小也是随意的）
  + 系统将**所有的空闲块**都链接在一个**双重循环链表结构**的可利用空间表中
  + 分配可按**首次拟合**进行，也可按**最佳拟合**进行
  + 系统的特点在于：在每个内存区的**头部**和**底部**两个边界上分别设有**标识**，以标识该区域为**占用块**或**空闲块**
    + 在**回收用户释放的空闲块**时**易于判别在物理位置上与其相邻的内存区域是否为空闲块**，以便将**所有地址连续的空闲存储区组合成一个尽可能大的空闲块**

### 可利用空间表的结构

+ 整个结点由**space**、**head**和**foot**总计3部分组成：
  + **space**为一组**地址连续的存储单元**，是可以分配给用户使用的内存区域
    + space的大小由**head**中的**size域**指示
  + space以**头部head**和**底部foot**作为它的两个**边界**
    + 在head和foot中分别设有**标志域tag**，且设定**空闲块**中**tag**的**值为“0”**，**占用块**中**tag**的**值为“1”**
    + **foot位于结点底部**，因此它的**地址**是随**结点中space空间的大小而变**的
+ 为讨论简便起见，假定**内存块的大小**以 **“字”为单位**来计，**地址**也以 **“字”为单位**来计：
  + 结点头部中的size域的值为整个结点的大小，包括头部head和底部foot所占空间，并假设**head和foot各占一个字的空间**，但在**分配时忽略不计**
+ C语言代码表示：

  ```C
  typedef struct WORD {  // 内存字类型
    union {  // head和foot分别是结点扼第一个字和最后的字
      WORD *llink;  // 头部域，指向前驱结点
      WORD *uplink;  // 底部域，指向本结点头部
    };
    int tag;  // 块标志，0为空闲，1为占用，头部和尾部均有
    int size;  // 头部域，块大小
    WORD *rlink;  // 头部域，指向后继结点
    OtherType other;  // 字的其他部分
  }WORD, head, foot, *Space;
  
  #define FootLoc(p) p + p->size - 1  // 指向p所指结点的底部
  ```

### 分配算法

+ 假设我们采用**首次拟合法**进行分配，则只要从表头指针pav所指结点起，在可利用空间表中进行查找，找到**第一个容量不小于请求分配的存储量**（$n$）的空闲块时，即可进行分配
  + 为了使整个系统更有效地运行，在边界标识法中还作了如下两条约定：
    + **问题**：假设找到的此块待分配的空闲块的容量为$m$个字（包括头部和底部），若每次分配只是从中分配$n$个字给用户，剩余$m - n$个字大小的结点仍留在链表中，则在**若干次分配**之后，链表中会出现一些**容量极小总也分配不出去的空闲块**，这就大大减馒了分配（查找）的速度
      + **弥补的办法**：
        + 选定一个**适当的常量$e$** ，**当$m - n \leqslant e$时，就将容量为$m$的空闲块整块分配给用户**；反之，**只分配其中$n$个字的内存块**
        + 同时，为了避免修改指针，约定将该结点中的**高地址部分**分配给用户
    + **问题**：如果**每次分配都从同一个结点开始查找**的话，势必造成**存储量小的结点密集在头指针pav所指结点附近**，这同样会增加查询较大空闲块的时间
      + **弥补的办法**：
        + 如果**每次分配从不同的结点开始进行查找**，使**分配后剩余的小块均匀地分布在链表**中，则可避免上述弊病
        + **实现的方法**：在**每次分配之后**，令**指针pav**指向**刚进行过分配的结点的后继结点**

### 回收算法

+ 一旦用户释放占用块，系统需立即回收以备新的请求产生时进行再分配；为了**使物理地址毗邻的空闲块结合成一个尽可能大的结点**，则首先需要**检查刚释放的占用块的左、右紧邻是否为空闲块**
  + 由于本系统在**每个内存区**（无论是占用块或空闲块）的**边界**上都设有**标志值**，则很容易辨明这一点
  + 假设用户**释放的内存区**的**头部地址为p**，则
    + 与其低地址紧邻的内存区的底部地址为`p - 1`
      + 若`(p - 1)->tag == 0`，则表明其**左邻**为**空闲块**
    + 与其高地址紧邻的内存区的头部地址为`p + p->size`
      + 若`(p + p->size)->tag == 0`，则表明其**右邻**为**空闲块**
  + 左、右邻区均有可能为占用块或空闲块，对于这4种情况其算法分别为：
    + 释放块的**左、右邻区**均为**占用块**：
      + 此时只要作**简单插入**即可
        + 由于边界标识法在按首次拟合进行分配时对可利用空间表的结构没有任何要求，则**新的空闲块插入在表中任何位置均可**
        + 简单的做法就是**插入在pav指针所指结点之前（或之后）**

        ```C
        p->tag = 0;
        FootLoc(p)->uplink = p;
        FootLoc(p)->tag = 0;
        // pav为当前指向链表中的结点；下同
        if(!pav)  // pav为空
          pav = p->llink = p->rlink = p;
        else {  // pav非空，插入到pav指针所指结点之前，并让pav重新指向p
          q = pav->llink;
          p->rlink = pav;
          p->llink = q;
          q->rlink = pav->llink = p;
          pav = p;  // 令刚释放的结点为下次分配时的最优先查询的结点
        }
        ```

    + 释放块的**左邻区**为**空闲块**，而**右邻区**为**占用块**：
      + 由于释放块的头部和左邻空闲块的底部毗邻，因此只要**改变左邻空闲块的结点**，**增加结点的size域的值**且**重新设置结点的底部**即可

        ```C
        n = p->size;  // 释放块的大小
        s = (p - 1)->uplink;  // 左邻空闲块的头部地址
        s->size += n;  // 设置新的空闲块大小
        f = p + n - 1;  // 前往新空闲块的底部
        f->uplink = s;  f->tag = 0;  // 设置新的空闲块底部的参数
        ```

    + 释放块的**左邻区**为**占用块**，而**右邻区**为**空闲块**：
      + 由于释放块的底部和右邻空闲块的头部毗邻，因此，当表中结点由原来的右邻空闲块变成合并后的大空闲块时，**结点的底部位置不变**，但**头部要变**，由此，链表中的指针也要变

        ```C
        t = p + p->size;  // 右邻空闲块的头地址
        p->tag = 0;  // 合并后的结点头部地址仍然为p
        q = t->llink;  // q为*t结点在可利用空间表中的前驱结点的头部地址
        p->llink = q;  q->rlink = p;  // 将p左侧和q右侧连接起来
        ql = t->rlink;  // ql为*t结点在可利用空间表中的后继结点的头部地址
        p->rlink = ql;  ql->llink = p;  // 将p右侧和ql左侧连接起来
        p->size += t->size;  // 新的空闲块的大小
        FootLoc(t)->uplink = p;  // t的底部指针（此时已经修改过size，故可用FootLoc）指向新结点的头部
        ```

    + 释放块的**左、右邻区**均为**空闲块**：
      + 为使3个空闲块连接在一起成为一个大结点留在可利用空间表中，只要**增加左邻空闲块的space容量**，同时在**链表中删去右邻空闲块结点**即可

        ```C
        n = p->size;  // 要释放块的大小
        s = (p - 1)->uplink;  // s指向左邻块
        t = p + p->size;  // t指向右邻块
        s->size += n + t->size;  // 以s为基础，设置新结点的大小
        q = t->llink;  ql = t->rlink;  // q指向t的前驱，ql指向t的后继
        q->rlink = ql;  ql->llink = q;  // 删去t；即让q的后继指向ql，ql的前驱指向q
        FootLoc(t)->uplink = s;  // 让t的底部指针（实际上就是s的底部指针）指向其头部
        ```

## 伙伴系统

+ **伙伴系统**（buddy system）是操作系统中用到的另一种动态存储管理方法；它和边界标识法类似，在用户提出申请时，分配一块大小“恰当”的内存区给用户；反之，在用户释放内存区时即回收
  + 所不同的是：在伙伴系统中，无论是**占用块**或**空闲块**，其**大小**均为 **$2$的$k$次幂**（$k$为某个正整数）
  + 例如，当用户申请$n$个字的内存区时，分配的占用块大小为$2^k$个字（$2^{k - 1} < n \leqslant 2^k$）；由此，在可利用空间表中的空闲块大小也只能是$2$的$k$次幂。若总的可利用内存容量为$2^m$个字，则空闲块的大小只可能为$2^0, 2^1, \cdots, 2^m$

### 可利用空间表的结构

+ 假设系统的可利用内存空间容量为$2^m$个字（地址从$0$到$2^m - 1$），则在**开始运行**时，**整个内存区**是一个**大小为$2^m$的空闲块**，在运行了一段时间之后，被分隔成若干占用块和空闲块
  + 为了再分配时查找方便起见，我们将**所有大小相同的空闲块**建于**一张子表中**；**每个子表**是一个**双重链表**，**这样的链表可能有$m + 1$个**，将**这$m + 1$个表头指针用向量结构组织成一个表**，这就是伙伴系统中的**可利用空间表**
+ 双重链表中的结点**结构**由**head**和**space**构成：
  + **head**为节点头部，是一个由4个域组成的记录，其中
    + **llink域**和**rlink域**分别指向同一链表中的**前驱**和**后继结点**
    + **tag域**为**值取“0”、“1”** 的**标志域**
    + **kval域**的值为$2$的幂次$k$
  + **space**是一个**大小为$2^k - 1$个字**的**连续内存空间**（和前面类似，仍假设head占一个字的空间）
+ 可利用空间表的**初始状态**：
  + **$m$个子表**都为**空表**，只有**大小为$2^m$的链表**中有**一个结点**，即**整个存储空间**
  + **表头向量的每个分量**由**两个域**组成：除**指针域**外，另设**nodesize域**表示**该链表中空闲块的大小**，以便分配时查找方便
+ C语言代码表示：

  ```C
  #define m 16  // 如果可利用空间总量为64K字，则其对应2的幂次为16；子表的个数为m + 1
  typedef struct WORD_b {  // 每个字的结点
    WORD_b *llink;  // 指向前驱结点
    int tag;  // 块标志，0为空闲，1为占用
    int kval;  // 块大小，值为2的幂次k
    WORD_b *rlink;  // 字的其他部分
    OtherType other;  // 字的其他部分
  }WORD_b, head;
  typedef struct HeadNode {  // 可利用空间表内的每个表头结点
    int nodesize;  // 该链表空闲块的大小
    WORD_b *first;  // 该链表的表头指针
  }FreeList[m + 1];  // 表头向量类型
  ```

### 分配算法

+ 当用户提出大小为$n$的内存请求时，首先在可利用表上寻找**结点大小与$n$相匹配的子表**
  + 若**此子表非空**，则将**子表中任意一个结点分配之**即可
  + 若**此子表为空**，则需从**结点更大的非空子表中去查找**，直至**找到一个空闲块**，则**将其中一部分分配给用户**，而将**剩余部分插入相应的子表**中
+ 假设分配前的可利用空间表的状态为从$p$到$p + 2^{k - i}$被分配，从$p + 2^{k - i}$到$p + 2^k$空闲：
  + 若$2^{k - 1} < n \leqslant 2^{k} - 1$，又**第$k + 1$个子表不空**，则只要**删除此链表中第一个结点**并**分配给用户**即可
  + 若$2^{k - 2} < n \leqslant 2^{k - 1} - 1$，此时由于**结点大小为$2^{k - 1}$的子表为空**，则需**从结点大小为$2^k$的子表中取出一块**，将**其中一半分配给用户**，**剩余的一半**作为一个**新结点**，**插入在结点大小为$2^{k - 1}$的子表**中
  + 若$2^{k - i - 1} < n \leqslant 2^{k - i} - 1$（$i$为小于$k$的整数），并且**所有结点小于$2^k$的子表均为空**，则同样需**从结点大小为$2^k$的子表中取出一块**，将**其中$2^{k - i}$的一小部分分配给用户**，**剩余部分分割成若干个结点**分别**插入在结点大小为$2^{k - i}, 2^{k - i + 1}, \cdots, 2^{k - 1}$的子表中**
    + 假设从第$k + 1$个子表中删除的结点的**起始地址为$p$** ，且假设**分配给用户的占用块的初始地址为$p$** （占用块为该空闲块的**低地址区**），则**插入上述子表的新结点的起始地址**分别为$2^{k - i}, 2^{k - i + 1}, \cdots, 2^{k - 1}$

      | 以$i = 3$为例 | $p$至$p + 2^{k - 3}$ | $p + 2^{k - 3}$至$p + 2^{k - 2}$ | $p + 2^{k - 2}$至$p + 2^{k - 1}$ | $p + 2^{k - 1}$至$p + 2^k$ |
      | :-----------: | :------------------: | :------------------------------: | :------------------------------: | :------------------------: |
      |               |         占用         |               空闲               |               空闲               |            空闲            |

### 回收算法

+ 在伙伴系统中，仅考虑**互为“伙伴”** 的**两个空闲块的归并**
  + 在**分配**时经常需要**将一个大的空闲块分裂成两个大小相等的存储区**，这两个由**同一大块分裂出来的小块**就称之 **“互为伙伴”**
    + 例如：假设 **$p$为大小为$2^k$的空闲块的初始地址**，**且$p \text{ MOD } 2^{k + 1} = 0$** ，则**初始地址为$p$和$p + 2^k$的两个空闲块**是**互为伙伴**的
  + 在伙伴系统中回收空闲块时，**只**当**其伙伴为空闲块**时才**归并成大块**
    + 也就是说，**若有两个空闲块**，即使**大小相同且地址相邻**，但**不是由同一大块分裂出来的**，也**不归并在一起**
  + 回收空闲块的过程：
    1. 首先判别其**伙伴是否为空闲块**
       + 若**否**，则只要将**释放的空闲块简单插入在相应子表**中即可
       + 若**是**，则需**在相应子表中找到其伙伴并删除之**，然后再**判别合并后的空闲块的伙伴是否是空闲块**
         + **起始地址为$p$，大小为$2^k$的内存块**，其**伙伴块**的**起始地址**为：$$\text{buddy}(p, k) = \begin{cases} p + 2^k & p \text{ MOD } 2^{k + 1} = 0 \\ p - 2^k & p \text{ MOD } 2^{k + 1} = 2^k \end{cases}$$
    2. 依此重复，直到**归并所得空闲块的伙伴不是空闲块**时，再**插入到相应的子表**中去

## 无用单元收集

+ **“无用单元”** 是指那些**用户不再使用而系统没有回收**的结构和变量
+ 解决问题的途径：
  + 使用**访问计数器**：
    + 在所有子表或广义表上增加一个**表头结点**，并设立一个 **“计数域”**，它的值为**指向该子表或广义表**的**指针数目**；只有当该**计数域的值为零**时，此**子表或广义表中结点才被释放**
  + **收集无用单元**：
    + 过程：
      1. 在程序运行的过程中，对所有的链表结点，**不管它是否还有用，都不回收**，直到**整个可利用空间表为空**
      2. 此时才**暂时中断执行程序**，将**所有当前不被使用的结点链接在一起**，成为一个**新的可利用空间表**，而后程序再**继续执行**
    + 显然，在一般情况下，是无法辨别哪些结点是当前未被使用的；然而，对于一个**正在运行的程序**，**哪些结点正在使用**是容易查明的
      + 只要从所有**当前正在工作的指针变量出发，顺链遍历**，那么，**所有链结在这些链上的结点**都是**占用**的；反之，可利用存储空间中的**其余结点**就都是**无用**的了
+ 收集**无用单元**应分两步进行：
  1. 对**所有占用结点**都**加上标志**
     + 可在每个结点上再加设一个**标志**（mark）**域**，假设在无用单元**收集之前**所有结点的**标志域均置为“0”**，则**加上标志**就是将**结点的标志域置为“1”**
  2. 对**整个可利用存储空间顺序扫描一遍**，将所有**标志域为“0”的结点**链接成一个**新的可利用空间表**
     + 值得注意的是：上述**第二步**是**容易进行**的，而**第一步**是在**极其困难的条件（即可利用存储几乎耗用殆尽）下进行**的，因此，人们的精力主要集中在研究标志算法上
+ 常用的**标志算法**：
  + **递归算法**：从上面所述可知，加标志的操作实质上是**遍历广义表**，将**广义表中所有结点的标志域赋值“1”**
    + 遍历（加标志）算法的**递归定义**如下：
      + 若**列表为空**，则**无需遍历**
      + 若是**一个数据元素**，则**标志元素结点**
      + 反之，则**列表非空**，首先**标志表结点**，然后**分别遍历表头和表尾**
    + **优点**：
      + 这个算法很简单，易于用允许递归的高级语言描述之
    + **缺点**：
      + 需要一个**较大的实现递归用的栈的辅助内存**，这部分内存是**不能用于动态分配**的
      + 由于**列表的层次不定**，使得**栈的容量不易确定**，除非是在内存区中开辟一个相当大的区域留作栈，否则就有可能由于在标志过程中因**栈的溢出**而使系统瘫痪
  + **非递归算法**：**程序中附设栈**（或**队列**）实现广义表的遍历
    + 从广义表的**存储结构**来看，表中有两种结点：
      + **元素结点**，结点中没有指针域
      + **表结点**，结点中包含两个指针域：表头指针和表尾指针
    + 可见此时**广义表类似于**二叉树的**二叉链表**，列表中的**元素结点**相当于二叉树中的**叶子结点**，可以类似于遍历二叉树写出遍历表的非递归算法，只是在算法中应尽量减少栈的容量
      + 例如，类似于二叉树的**前序遍历**，对广义表则为：当表非空时，在对表结点加标志后，先**顺表头指针逐层向下**对**表头加标志**，同时将**同层非空且未加标志的表尾指针**依次**入栈**，直到**表头为空表**或**为元素结点**时**停止**，然后**退栈**取出**上一层的表尾指针**；反复上述进行过程，直到栈空为止
        + 这个过程也可以称做**深度优先搜索遍历**，因为它和图的深度优先搜索遍历很相似
        + 显然，还可以类似于图的广度优先搜索遍历，对列表进行**广度优先搜索遍历**，或者说是对列表按层次遍历
    + **优点**：
      + 附设的**栈或队列的容量**比**递归算法中的栈的容量小**
      + **耗费时间节省更多**
    + **缺点**：
      + 和递归算法有同样的问题仍**需要一个不确定量的附加存储**，因此也不是理想的方法
  + 利用**表结点本身的指针域标记遍历路径**的算法：算法中设定了3个互相关联的指针**p**、**q**、**t**
    + 当**p指向某个表结点**时，**t**指向**p的母表结点**，**q**指向**p的表头或表尾**
      1. 当**q**指向**p的表头**时，可能有3种情况出现：
         + **p的表头**只是**一个元素结点**，则**遍历表头仅需对该表头结点打上标志**后即令**q指向p的表尾**
         + **p的表头**为**空表**或是**已加上标志的子表**，则**无需遍历表头**，只要令**q指向p的表尾**即可
         + **p的表头**为**未加标志的子表**，则需先遍历表头子表，即**p应赋q的值**， **t相应往下移动**改**赋p的值**
         + 为了记下**t指针移动的路径**，以便在p退回原结点时同时能找到p的母表结点（即使t退回到原来的值），则在修改这个指针的值之前，应**先记下t移动的路径**，即令**p所指结点的hp域（指示表头的指针域）的值**为**t**，且**tag域**的**值为“0”**
      2. 当**q**指向**p的表尾**时，可能有2种情况出现：
         + **p的表尾**为**未加标志的子表**，则需**遍历表尾的子表**，同样p、t指针要作相应的移动
           + 为了记下**当前表结点的母表结点**，同样要在改动p、t指针的值之前先记下路径；即令**p所指结点的tp域（指示表尾的指针域）的值**改为**t**，然后令**t赋值p**，**p赋值q**
         + **p的表尾**为 **“空”** 或是**已加上标志的子表**，此时表明**p所指的表已加上标志**，则**p**应退回到**其母表结点即t所指结点**，相应地**t**也应后退一步，即退到**t结点的母表结点**
    + 综上所述可知，**t的移动路径**已**记录在t结点的hp域或tp域**中，究竟是**哪一个**则要由**辨别tag域的值**来定；它不仅指示t应按哪个指针所指路径退回，而且指示了下一步应做什么
      + 若**t结点**是其**母表表头**，则应继续**遍历其母表的表尾**
      + 若**t结点**是其**母表的表尾**，则应继续**找更高一层的母表结点**
    + **优点**：
      + 标志时**不需要附加存储**，使动态分配的可利用空间得到充分利用
    + **缺点**：
      + 在算法中，几乎是每个表结点的指针域的值都要作两次改变，因此**时间上的开销相当大**
      + **一旦发生中断，整个系统瘫痪，无法重新启动运行**
+ 收集无用算法的**时间分析**：
  + 假设**总的占用结点数**为$N$，则标志过程所需时间为$c_1 N$（其中$c_1$为某个常数）；第二步是从可用空间的第一个结点起，顺序扫描，将所有未加标志的结点链结在一起，假设**可用空间**总共**含有$M$个结点**，则所需时间为$c_2 M$（其中$c_2$为某个常数）
  + 由此，**收集算法总的时间**为$c_1 N + c_2 M$，同时**收集到的无用结点个数**为$M - N$，**收集一个无用结点**的**平均时间**为$\frac{c_1 N + c_2 M}{M - N}$

## 存储紧缩

+ 在整个动态存储管理过程中，不管哪个时刻，**可利用空间**都是一个**地址连续的存储区**，在编译程序中称之为 **“堆”**，每次分配都是从这个可利用空间中划出一块
  + 其实现办法是：**设立一个指针**，称之为**堆指针**，**始终指向堆的最低**（或**最高**）**地址**
    + 当用户**申请$N$个单位的存储块**时，堆指针向**高地址**（或**低地址**）**移动$N$个存储单位**，而**移动之前的堆指针的值**就是**分配给用户的占用块的初始地址**
    + 回收时，由于系统的可利用空间始终是一个地址连续的存储块，因此回收时必须将**所释放的空闲块合并到整个堆上**才能重新使用，这就是 **“存储紧缩”** 的任务；通常有两种做法：
      + **一旦有用户释放存储块**即进行回收紧缩
      + 在程序执行过程中不回收用户随时释放的存储块，直到**可利用空间不够分配**或**堆指针指向最高地址**时才进行存储紧缩
+ 对于**存储紧缩**，首先要对**占用块**进行 **“标志”**（方法参见上一章节），然后进行以下操作：
  1. 计算占用块的新地址：从**最低地址**开始**巡查整个存储空间**，对**每一个占用块**找到**它在紧缩后的新地址**
     + 为此，需**设立两个指针**随**巡查向前移动**，这两个指针分别指示**占用块**在**紧缩之前的原地址**和**紧缩之后的新地址**
     + 因此，在每个占用块的第一个存储单位中，除了设立**长度域**（存储该占用块的大小）和**标志域**（存储区别该存储块是占用块或空闲块的标志）之外，还需设立一个**新地址域**，以存储占用块在紧缩后应有的新地址，即建立一张新、旧地址的对照表
  2. 修改用户的**初始变量表**，以便在存储紧缩后用户程序能继续正常运行
  3. **检查每个占用块中存储的数据**；若有**指向其他存储块的指针**，则需作相应**修改**
  4. 将所有**占用块迁移到新地址**去；这实质上是作传送数据的工作
     + 完成**存储紧缩**后，需要将**堆指针**赋以**新值**（即**紧缩后的空闲存储区**的**最低地址**）
