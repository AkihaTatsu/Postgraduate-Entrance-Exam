# 绪论

## 什么是数据结构

+ 数据结构主要研究**非数值计算问题**，非数值计算问题**无法用数学方程建立数学模型**

## 基本概念和术语

### 数据、数据元素、数据项和数据对象

+ **数据**（Data）是**客观事物的符号表示**，是所有能输入到计算机中并被计算机程序处理的符号的总称
  + 如数学计算中用到的整数和实数，文本编辑中用到的字符串，多媒体程序处理的图形、图像、声音及动画等通过特殊编码定义后的数据
+ **数据元素**（Data Element）是**数据的基本单位**，在计算机中通常作为一个整体进行考虑和处理
  + 在有些情况下，数据元素也称为元素、记录等
  + 数据元素用于**完整地描述一个对象**，如前一节示例中的一名学生记录，树中棋盘的一个格局（状态），以及图中的一个顶点等
+ **数据项**（Data Item）是**组成数据元素的、有独立含义的、不可分割的最小单位**
  + 例如，学生基本信息表中的学号、姓名、性别等都是数据项
+ **数据对象**（Data Object）是**性质相同的数据元素的集合**，是数据的一个子集
  + 例如：整数数据对象是集合$N=\{0,\pm 1,\pm 2, \cdots\}$，字母字符数据对象是集合$C=\{\text{‘A’},\text{‘B’},\cdots,\text{‘Z’},\text{‘a’}, \text{‘b’}，\cdots,\text{‘z’}\}$，学生基本信息表也可以是一个数据对象
  + 不论数据元素集合是无限集（如整数集），或是有限集（如字母字符集），还是由多个数据项组成的复合数据光素（如学生表）的集合，只要**集合内元素的性质均相同**，都可称之为一个数据对象

### 数据结构

+ 数据结构包括**逻辑结构**和**存储结构**两个层次
+ **逻辑结构**：数据的逻辑结构是**从逻辑关系上描述数据**，它与数据的存储无关，是独立于计算机的；因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型
  + 基本类型：
    + **集合结构**：数据元素之间**除了“属于同一集合”的关系外，别无其他关系**
    + **线性结构**：数据元素之间存在**一对一**的关系
      + 一般线性表：如线性表
      + 特殊线性表：如栈和队列、字符串
      + 线性表的推广：如数组、广义表
    + **树结构**：数据元素之间存在**一对多**的关系
      + 例：树、二叉树
    + **图结构 / 网状结构**：数据元素之间存在**多对多**的关系
      + 例：有向图、无向图
  + **线性结构**：包括线性表、栈和队列、字符串、数组、广义表等
  + **非线性结构**（集合结构、树结构、图结构 / 网状结构）：包括树、二叉树、有向图、无向图等
+ **存储结构**（也称为**物理结构**）：数据对象在计算机中的存储表示称为数据的存储结构
  + **顺序存储结构**：顺序存储结构是**借助元素在存储器中的相对位置**来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述
  + **链式存储结构**：为了表示结点之间的关系，**需要给每个结点附加指针字段，用于存放后继元素的存储地址**

### 数据类型和抽象数据类型
+ **数据类型**（Data Type）：一个**值的集合**和**定义在这个值集上的一组操作**的总称
  + 例：C语言中的整型变量，其值集为某个区间上的整数（区间大小依赖于不同的机器），定义在其上的操作为加、减、乘、除和取模等算术运算
+ **抽象数据类型**（Abstract Data Type，ADT）：一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：**数据对象**、**数据对象上关系的集合**以及**对数据对象的基本操作**的集合.
  + 定义格式：
  ```
  ADT 抽象数据类型名 {
    数据对象: 〈数据对象的定义〉
    数据关系: 〈数据关系的定义〉
    基本操作: 〈基本操作的定义〉
  }ADT 抽象数据类型名
  ```
  + 其中：
    + **数据对象**和**数据关系**的定义采用**数学符号和自然语言描述**
    + **基本操作**的定义格式为:
    ```
    基本操作名 (参数表)
      初始条件: 〈初始条件描述〉
      操作结果: 〈操作结果描述〉
    ```

## 抽象数据类型的表示与实现（略）

## 算法和算法分析

### 算法的定义及特性

+ **算法**（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列；一个算法必须满足以下五个重要特性：
  + **有穷性**：一个算法必须总是在**执行有穷步后结束**，且**每一步都必须在有穷时间内完成**
  + **确定性**：对于每种情况下所应执行的操作，在算法中都有确切的规定，**不会产生二义性**，使算法的执行者或阅读者都能明确其含义及如何执行
  + **可行性**：算法中的所有操作都可以**通过已经实现的基本操作运算**执行**有限次**来实现
  + **输入**：一个算法有**零个或多个输入**；当用函数描述算法时，输人往往是通过形参表示的，在它们被调用时，从主调函数获得输入值
  + **输出**：一个算法有**一个或多个输出**，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义；当用函数描述算法时，输出多用返回值或引用类型的形参表示

### 评价算法优劣的基本标准

+ **正确性**：在合理的数据输入下，能够在有限的运行时间内得到正确的结果
+ **可读性**：一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性；可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改
+ **健壮性**：当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果
+ **高效性**：高效性包括时间和空间两个方面
  + **时间高效**是指算法设计合理，执行效率高，可以用**时间复杂度**来度量
  + **空间高效**是指算法占用存储容量合理，可以用**空间复杂度**来度量

### 算法的时间复杂度

#### 问题规模和语句频度

+ 影响算法时间代价的最主要因素是**问题规模**：算法求解问题输入量的多少，是问题大小的本质表示，一般用整数$n$表示
+ 一个算法的执行时间大致上等于其**所有语句执行时间**的总和，而语句的执行时间则为**该条语句的重复执行次数**和**执行一次所需时间**的**乘积**
+ 一条语句的重复执行次数称作**语句频度**（Frequency Count）
+ 设每条语句执行一次所需的时间均是单位时间，则一个算法的**执行时间**可用**该算法中所有语句频度之和**来度量

#### 算法的时间复杂度定义

+ 一般情况下，算法中基本语句重复执行的次数是问题规模$n$的某个函数$f(n)$，算法的时间量度记作$$T(n)= O(f(n))$$它表示**随问题规模$n$的增大，算法执行时间的增长率和$f(n)$的增长率相同**，称做算法的**渐近时间复杂度**，简称**时间复杂度**（Time Complexity）
+ $O$的**严格定义**：
  + 若$T(n)$和$f(n)$是定义在正整数集合上的两个函数，则$T(n) = O(f(n))$表示存在正的常数$C$和$n_0$，使得当$n \geqslant n_0$时都满足$0 \leqslant T(n) \leqslant Cf(n)$

#### 算法的时间复杂度举例

+ 若$f(n) = a_m n^m + a_{m - 1}n^{m - 1} + \cdots + a_1 n + a_0$是一个$m$次多项式，则$T(n) = O(n^m)$
  + 若语句频度为1，**算法的执行时间是一个与问题规模$n$无关的常数**，则该算法的时间复杂度为$T(n)=O(1)$，称为**常量阶**
  + $O(n)$称为**线性阶**，$O(n^2)$称为**平方阶**，$O(n^3)$称为**立方阶**
+ 若$2^{f(n)} \leqslant n, f(n) \leqslant \log_2 n$，则算法的时间复杂度为$T(n)= O(log_2 n)$，称为**对数阶**
  + $O(n\log_2 n)$称为**线性对数阶**
  + $O(2^n)$称为**指数阶**
+ 常见时间复杂度数量级排序：$$O(1) \leqslant O(\log_2 n) \leqslant O(n) \leqslant O(n\log_2 n) \leqslant o(n^2) \leqslant O(n^3) \leqslant \cdots \leqslant O(n^k) \leqslant O(2^n)$$

#### 最好、最坏和平均时间复杂度

+ 算法的时间复杂度不仅与问题的规模有关，还与问题的其他因素、输入数据本身的特征有关；因此，有时会对算法有最好、最坏以及平均时间复杂度的评价
  + 某些排序的算法，其执行时间与待排序记录的初始状态有关
+ 称算法在**最好情况下的时间复杂度**为**最好时间复杂度**，指的是算法计算量可能达到的**最小值**
+ 称算法在**最坏情况下的时间复杂度**为**最坏时间复杂度**，指的是算法计算量可能达到的**最大值**
+ 算法的**平均时间复杂度**是指算法在所有可能情况下，按照**输入实例以等概率出现**时，**算法计算量的加权平均值**

### 算法的空间复杂度

+ 关于算法的存储空间需求，类似于算法的时间复杂度,我们采用**渐近空间复杂度**作为算法所需存储空间的量度，简称**空间复杂度**（Space Complexity），它也是问题规模n的函数，记作：$$S(n) = O(f(n))$$
  + 注意是需要**辅助空间**的大小，不考虑输入数据本身占用的存储空间！
+ 若算法执行时**所需要的辅助空间相对于输入数据量而言是个常数**，则称这个算法为**原地工作**，辅助空间为$O(1)$
+ 有的算法需要**占用临时的工作单元数与问题规模$n$有关**，如第8章介绍的归并排序算法就属于这种情况

