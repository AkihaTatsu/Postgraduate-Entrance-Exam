# 串

## 串类型的定义

+ **串**（string）（或**字符串**）是由**零个或多个字符**组成的**有限序列**，一般记为$$s = \text{"}a_1a_2\cdots a_n\text{"}$$
  + 其中：
    + $s$是串的**名**，用**双引号括起来的字符序列**是串的**值**
    + $a_i(1\leqslant i\leqslant n)$可以是字母、数字或其他字符
    + 串中**字符的数目**$n$称为串的**长度**
    + **零个字符的串**称为**空串**（null string），其长度为零
      + 为了清楚起见，以后我们用**符号“∅”** 来表示“**空串**”
  + 子串相关：
    + 串中**任意个连续的字符组成的子序列**称为该串的**子串**
    + **包含子串的串**相应地称为**主串**
    + 通常称**字符在序列中的序号**为该字符在串中的**位置**
    + **子串在主串中的位置**则以**子串的第一个字符在主串中的位置**来表示
  + 称两个串是**相等**的，当且仅当这两个串的**值相等**；也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等
  + 由**一个或多个空格组成的串“ ”**称为**空格串**（blank string，请注意：此处**不是**~~空串~~），其长度为**串中空格字符的个数**
+ 串的**抽象数据类型性定义**：

  ```C
  ADT String{
    数据对象：D={a[i]|a[i]∈CharacterSet, i=1,2,…,n, n≥0}
    数据关系：R1={<a[i-1],a[i]>|a[i-1], a[i]∈D, i=2,…,n}
    基本操作：
      StrAssign(&T, chars)
        初始条件：chars是字符串常量
        操作结果：生成一个其值等于chars的串T
      strcopy(&T, S)
        初始条件：串S存在
        操作结果：由串S复制得串T
      StrEmpty(s)
        初始条件：串S存在
        操作结果：若S为空串，则返回true，否则返回false
      strCompare(S, T)
        初始条件：串S和T存在
        操作结果：若S > T，则返回值 > 0；若S = T，则返回值 = 0；若S < T，则返回值 < 0
      strLength(s)
        初始条件：串S存在
        操作结果：返回S的元素个数，称为串的长度
      clearString(&S)
        初始条件：串S存在
        操作结果：将s清为空串
      Concat(&T, s1, S2)
        初始条件：串S1和s2存在
        操作结果：用T返回由S1和S2联接而成的新串
      substring(&Sub,  S, pos,  len)
        初始条件：串S存在，1 ≤ pos ≤ StrLength(S)且0 ≤ len ≤ StrLength(S) - pos + l
        操作结果：用Sub返回串S的第pos个字符起长度为len的子串
      Index(S, T, pos)
        初始条件：串S和T存在，T是非空串，1 ≤ pos ≤ StrLength(S)
        操作结果：若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置；否则函数值为0
      Replace(&s, T, v)
        初始条件：串S，T和v存在，T是非空串
        操作结果：用v替换主串S中出现的所有与T相等的不重叠的子串
      strInsert(&s, pos, T)
        初始条件：串S和T存在，1 ≤ pos ≤ StrLength(S) + 1
        操作结果：在串S的第pos个字符之前插人串T
      strDelete(&S, pos, len)
        初始条件：串S存在，1 ≤ pos ≤ StrLength(S) - len + 1
        操作结果：从串S中删除第pos个字符起长度为len的子串
      Destroystring(&s)
        初始条件：串S存在
        操作结果：串S被销毁
  }ADT String
  ```


## 串的表示和实现

### 定长顺序存储表示

+ 类似于线性表的顺序存储结构，用**一组地址连续的存储单元**存储串值的字符序列；按照预定义的大小，为每个定义的串弯量分配一个固定长度的存储区，从而可用定长数组作如下描述：

  ```C
  #define MAXSTRLEN 255
  typedef unsigned char SString[MAXSTRLEN + 1];
  ```
  注意：**以下字符串表示中默认使用定长顺序存储，因此第i个字符的下表为i（即S[i]），而S[0]可以用于存储字符串实际长度！**

+ 在定长顺序存储的基础上，如果需要拼接两个串，而**两个串的总长度超过了上界MAXSTRLEN**，要将串（一般是第一个串）进行**截断**

### 堆分配存储表示

+ 在C语言中，存在一个称之为“堆”（Heap）的自由存储区，可以**为每个新产生的串动态分配一块实际串长所需的存储空间**，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时为了以后处理方便，约定**串长也作为存储结构的一部分**；这种字符串的存储方式也称为串的**堆式顺序存储结构**

  ```C
  typedef struct{
    char *ch;
    int length;
  }HString;
  ```

+ 对于堆分配存储，当使用串的复制、拼接等操作时，一般先将原串占用空间释放，然后分配结果串长的新空间

### 串的块链存储表示

+ 对于串，每个结点可以只包含一个字符，也可以包含多个字符（即“块”）；当包含多个字符时，如果最后一个节点没有填满，一般会补充'#'或其他非串值字符

  ```C
  #define CHUNKSIZE 80
  typedef struct Chunk{
    char ch[CHUNKSIZE];
    struct Chunk *next;
  }Chunk;
  typedef struct{
    Chunk *head, *tail;
    int curlen;  // 当前长度（Current Length）
  }LString;
  ```

+ 考察存储密度的定义：$$\text{存储密度} = \frac{\text{数据元素本身占用的存储量}}{\text{结点结构占用的存储量}}$$
  + 存储密度小（如结点大小为1时），运算处理方便，然而，存储占用量大
  + 如果在串处理过程中需进行内、外存交换的话，则会因为内、外存交换操作过多而影响处理的总效率
+ 串值的链式存储结构对某些串操作，如联接操作等，有一定方便之处，但总地说来，**不如顺序存储结构灵活**，它**占用存储量大**且**操作复杂**

## 串的模式匹配算法

### 求子串位置的定位函数Index(S, T, pos)

+ **算法思路**（BF算法）：从某个位置pos开始逐位比较，如果出现不相同则主串从下一位开始比较，直到确定每一位都相同为止
+ **算法步骤**：
  1. 分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i初值为pos，j初值为1
  2. 如果两个串均未比较到串尾，即i和j均分别小于等于S和T的长度时，则循环执行以下操作：
     + S[i].ch和T[j].ch比较，若相等，则i和j分别指示串中下个位置（`i++; j++;`），继续比较后续字符
     + 若不等，指针后退重新开始匹配，从主串的下一个字符（i = i - j + 2）起再重新和模式的第一个字符（j = 1）比较
  3. 如果j > T.length，说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号（i - T.length）；否则称匹配不成功，返回0
+ **时间复杂度**：主串、子串长度分别为$m$、$n$，则时间复杂度**最好$O(m + n)$，最坏$O(m * n)$**

### 模式匹配的一种改进算法（KMP算法）

+ **目标**：让BF算法中母串待比较字符位置i**不回溯**（只往后移动，不往前移动）
+ 算法中用到的**概念**和**结构**：
  + **公共前后缀**：一个字符串的**所有前缀连续子串**和**所有后缀连续子串**中**相等的子串**
    + 例："ABABA"的前缀有"A", "AB", "ABA", "ABAB"；后缀有"BABA", "ABA", "BA", "A"；则**公共前后缀**有 **"A", "ABA"**
  + **最长公共前后缀**：一个串的公共前后缀中最长的
    + 例：
  
      | 字符串 | 最长公共前后缀 | 最长公共前后缀的长度 |
      | :----: | :------------: | :------------------: |
      | ABABA  |      ABA       |          3           |
      |  ABC   |       /        |          0           |
      |  ABA   |       A        |          1           |
      | ABCAB  |       AB       |          2           |
  
  + **部分匹配值（Partial March）的表**：串本身和所有前缀构成的这些子串中，每个子串的最长公共前后缀长度
    
    + 例：对串"ABCABD"，有
    
      |  子串  | 最长公共前后缀 | 最长公共前后缀的长度 |
      | :----: | :------------: | :------------------: |
      |   A    |       /        |          0           |
      |   AB   |       /        |          0           |
      |  ABC   |       /        |          0           |
      |  ABCA  |       A        |          1           |
      | ABCAB  |       AB       |          2           |
      | ABCABD |       /        |          0           |
    
      从而该字符串部分匹配值的表PM为
    
      |  字符串  |  A   |  B   |  A   |  B   |  D   |
      | :------: | :--: | :--: | :--: | :--: | :--: |
      | PM的下标 |  1   |  2   |  3   |  4   |  5   |
      | PM的取值 |  0   |  0   |  1   |  2   |  0   |
    
  + **next表**：
    + 注意到在模式串的P[j]位置出现“**失配**”（匹配不一致）时，其应当向右移动的位数为 **“已匹配的字符数”（j - 1）减去“对应部分匹配值”（PM[j - 1]）**
      + 即Move = j - 1 - PM[j - 1]；**移动后的j'** = j - (j - 1 - PM[j - 1]) **= PM[j - 1] + 1**
      + 例子：
    
        |     待匹配串      |  A   |  B   |  A   |   B   |     A     |  B   |  D   |
        | :---------------: | :--: | :--: | :--: | :---: | :-------: | :--: | :--: |
        |   出现失配时的i   |      |      |      |       |   i = 5   |      |      |
        | 模式串 & PM的下标 |  1   |  2   |  3   |   4   |     5     |      |      |
        | 模式串（移动前）  |  A   |  B   |  A   |   B   |     D     |      |      |
        |     位移前的j     |      |      |      |       | **j = 5** |      |      |
        |  模式串PM的取值   |  0   |  0   |  1   | **2** |     0     |      |      |
        | 模式串（移动后）  |      |      |  A   |   B   |     A     |  B   |  D   |
        |     位移后的j     |      |      |      |       |   j = 3   |      |      |
        
        可以看到，此处位移5 - 1 - PM[5 - 1] = 2位，位移后的j = PM[3] = 2，i则保持不变
    
    + 为了简化计算，**将PM的每一个元素后移一位，并在最开始补上-1（表示一开始就匹配失败，则右移一位）**，得到**next数组**
      + 由于**移动后的j' = next[j] + 1**，也可以**在此时的next数组基础上全体元素加1**，从而得到最简化的next数组
    
        |        字符串        |  A   |  B   |  A   |  B   |  D   |
        | :------------------: | :--: | :--: | :--: | :--: | :--: |
        | 部分匹配值的表（PM） |  0   |  0   |  1   |  2   |  0   |
        |     next的形式一     |  -1  |  0   |  0   |  1   |  2   |
        |     next的形式二     |  0   |  1   |  1   |  2   |  3   |
    
      + 在实际题目中，两种形式都有可能出现，根据**开头元素是否为-1**进行区别判断！
    + 求解next的算法：
    
      ```C
      void get_next(SString S, int next[]) {
        int i = 1, j = 0;  // i为当前检查的字符，j为S[1]至S[i - 1]构成字符串的部分匹配值
        next[1] = 0;  // next[1]默认置0
        while(i < StrLength(S)) {
          if(j == 0 || S[i] == S[j]) {
            // j == 0：由于next的下标与字符串相同，从1开始，故next[0]无意义，需要跳过；而第1个字符对应的部分匹配值必定为0，即next[2]必然等于1
            // S[i] == S[j]：前后检查字符相同，则部分匹配值长度 + 1并检查下一组字符
            ++i; ++j;
            next[i] = j;  // 存储此时的部分匹配值
          }
          else
            j = next[j];  // j通过去部分匹配值从而回到上一次检查的最长公共前后缀的末端位置
        }
      }
      ```
  
+ **KMP算法的步骤**：
  1. 求出待匹配模式T的部分匹配表next
  2. 分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i初值为pos，j初值为1
  3. 如果两个串均未比较到串尾，即i和j均分别小于等于S和T的长度时，则循环执行以下操作：
     + S[i]和T[j]比较，若相等，则i和j分别指示串中下个位置（`i++; j++;`），继续比较后续字符
     + **若不等，则取`j = next[j]`，即跳到子串的next[j]位置重新开始比较**
  4. 如果j > T.length，说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号（i - T.length）；否则称匹配不成功，返回0

     ```C
     int Index_KMP(SString S, SString T, int pos) {
       int i = 1, j = pos;  // i从索引1开始比较
       while(i <= StrLength(S) && j <= StrLength(T)) {
         if(j == 0 || S[i] == T[j]) {
           // j == 0：由于T的下标从1开始，故T[0]无意义，需要跳过
           // S[i] == S[j]：检查字符相同，则检查下一组字符
           ++i; ++j;
         }
         else  // S[i] != S[j]，进行位移
           j = next[j];  // 位移后j = next[j]
       }
       if(j > StrLength(T))  // j > StrLength(T)即j没有因为S[i] != S[j]而被置为next[j]：一个小于等于StrLength{T}的值，即完成了匹配
         return i - T[0];
       else
         return 0;
     }
     ```

+ **KMP算法的改进**：
  + 前面定义的next数组在某些情况下尚有缺陷：
    + 例如模式“aaaab”在和主串“aaabaab”匹配时：
      + 当i = 4、j = 4时发生失配
      + 如果使用原先的next（`[0, 1, 2, 3, 4]`），则需要进行i = 4、j = 3，i = 4、j = 2，i = 4、j = 1三次比较，然而实际上这些符号是相同的
      + 问题在于**不应当在模式串上出现S[j] = S[next[j]]**
    + 可以引入修正的next数组（nextval），从而简化该计算
      + nextval的核心改进点：**当S[j] = S[next[j]]时，将next[j]修正为next[next[j]]**
        + **字符串下标从1开始**时，**next**使用**以0开头的那一类**
        + **字符串下标从0开始**时，**next**使用**以-1开头的那一类**
        + 修正应当**从左到右进行**
      + 代码表示：
    
      ```C
      void get_nextval(SString S, int nextval[]) {
        int i = 1, j = 0;
        nextval[1] = 0;
        while(i < StrLength(S)) {
          if(j == 0 || S[i] == S[j]) {
            ++i; ++j;
            if(S[i] != S[j])  // 如果此时S[i] != S[j]，则正常存储nextval[i] = j
              nextval[i] = j;  // 存储此时的部分匹配值
            else  // 如果此时S[i] == S[j]，即S[i] = S[next[i]]，则作修正nextval[i] = nextval[j] = nextval[nextval[i]]
              nextval[i] = nextval[j];
          }
          else
            j = nextval[j];  // j通过去部分匹配值从而回到上一次检查的最长公共前后缀的末端位置
        }
      }
      ```
    
    + 改进前后的效果：
    
      | 字符串  |  A   |  A   |  A   |  A   |  B   |
      | :-----: | :--: | :--: | :--: | :--: | :--: |
      |  下标   |  1   |  2   |  3   |  4   |  5   |
      |  next   |  0   |  1   |  2   |  3   |  4   |
      | nextval |  0   |  0   |  0   |  0   |  4   |

+ **KMP算法与传统匹配算法（BF算法）的比较**：
  + 虽然BF算法的时间复杂度是$O(n \times m)$，但在一般情况下，其实际的执行时间近似于$O(n + m)$，因此至今仍被采用
  + KMP算法**仅当模式与主串之间存在许多“部分匹配”的情况下**，才显得比BF算法**快得多**
  + 但是KMP算法的最大特点是指示主串的指针不需回溯，整个匹配过程中，对主串仅需从头至尾扫描一遍，这对**处理从外设输人的庞大文件**很有效，**可以边读入边匹配，而无需回头重读**

## 串操作应用举例

### 文本编辑（略）

### 建立词索引表

+ **词表**为**线性表**，只存放一本书的书名中若干关键词，其数量有限，则采用**顺序存储结构**即可，其中每一个词是一个字符串

  | 书号 |                      书名                      |
  | :--: | :--------------------------------------------: |
  | 005  |            Computer Data Structures            |
  | 010  |        Introduction to Data Structures         |
  | 023  |        Fundamentals of Data Structures         |
  | 034  | The Design and Analysis of Computer Algorithms |
  | 050  |       Introduction to Numerical Analysis       |
  | 067  |               Numerical Analysis               |

+ **索引表**为**有序表**，虽然是动态生成，在生成过程中需要频繁进行插入操作，但考虑索引表主要为查找用，为了提高查找效率（例如采用折半查找法），宜采用**顺序存储结构**

  |    关键词    |   书号索引    |
  | :----------: | :-----------: |
  |  algorithms  |      034      |
  |   analysis   | 034, 050, 067 |
  |   computer   |   005, 034    |
  |     data     | 005, 010, 023 |
  |    design    |      034      |
  | fundamentals |      023      |
  | introduction |   010, 050    |
  |  numerical   |   050, 067    |
  |  structures  | 005, 010, 023 |

  